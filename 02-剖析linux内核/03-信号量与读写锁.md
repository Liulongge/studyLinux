# 信号量与读写锁

## 信号量与spinlock
    1、semaphore是操作系统常用的同步原语。spinlock忙等待的锁，而信号量允许进城进入睡眠状态。信号量最经典的案例：生产者与消费者问题。

信号量数据结构类型源码分析：
```C
struct semaphore {
	raw_spinlock_t		lock; // lock则为spinlock变量，用于对信号量结构里面count/wait_list保护
	unsigned int		count; // 表示允许进入临界区的内核执行路径个数
	struct list_head	wait_list; // 链表，管理所有在此信号量上睡眠的进程
};

#define __SEMAPHORE_INITIALIZER(name, n)				\
{									\
	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\
	.count		= n,						\
	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\
}

#define DEFINE_SEMAPHORE(name)	\
	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)


static inline void sema_init(struct semaphore *sem, int val) // 信号量初始化
{
	static struct lock_class_key __key;
	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
	lockdep_init_map(&sem->lock.dep_map, "semaphore->lock", &__key, 0);
}
// 进入不可中断的睡眠状态
extern void down(struct semaphore *sem);
// 在争用信号量失败时进入中断睡眠状态
extern int __must_check down_interruptible(struct semaphore *sem);
extern int __must_check down_killable(struct semaphore *sem);
// 返回结果0，表示获取锁，返回1表示获取失败
extern int __must_check down_trylock(struct semaphore *sem);

extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
extern void up(struct semaphore *sem);

int down_interruptible(struct semaphore *sem)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_interruptible(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}

void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list))) // 如果没有线程等待（链表为空），则count++
		sem->count++;
	else // 如果有现成等待，则唤醒线程
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}

```

## 读写锁与mutex互斥体
        什么时候使用读者信号量，什么时候使用写信号量，判断标准？
        读写信号量使用的自旋等待机制是如何实现的？

        信号量缺点：没有区分临界区的读写属性。读写锁允许多个线程并发的读访问临界区，但是写访问限制一个线程。读写锁能够提高并发性。
    读写锁特性：
        1、允许多个读者同时进入临界区，但同一时刻写着不能进入；
        2、同一时刻只允许一个写者进入临界区；
        3、读者和写者不能同时进入临界区。

### 读者信号量数据结构类型源码
``` C
typedef struct {
	arch_rwlock_t raw_lock;
#ifdef CONFIG_GENERIC_LOCKBREAK
	unsigned int break_lock;
#endif
#ifdef CONFIG_DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} rwlock_t;

struct rw_semaphore {
	long count; // 表示读写信号量计数
	struct list_head wait_list; // 链表，管理所有在此信号量上睡眠的进程
	raw_spinlock_t wait_lock; // spinlock变量，用于对读写信号量count成员原子操作和保护
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
	struct optimistic_spin_queue osq; /* spinner MCS lock */
	/*
	 * Write owner. Used as a speculative check to see
	 * if the owner is running on the cpu.
	 */
	struct task_struct *owner; // 当写者成功获取锁时，owner指向锁持有者的task_struct
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map	dep_map;
#endif
};
```

### 写者锁：写者调用down_write函数获取信号量api
``` C
/*
 * lock for writing
 */
void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}

```
